<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>3craft</title>
        <style>
			body { margin: 0; }
            #autoJumpButton {
                position: absolute;
                left: 20px;
                top: 20px;
            }
            #canFlyButton {
                position: absolute;
                left: 20px;
                top: 42px;
            }
		</style>
    </head>
    <body>
        <button id="autoJumpButton" onclick="toggleAutoJump()">Auto Jump: On</button>
        <button id="canFlyButton" onclick="toggleCanFly()">Can Fly: Off</button>
        <script src="js/vendor/three.js"></script>
        <script src="js/vendor/PointerLockControls.js"></script>
        <script src="js/vendor/perlin.js"></script>
        <script type="text/javascript">
            noise.seed(Math.random())
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x00ffff);
 		    scene.fog = new THREE.Fog(0x00ffff, 10, 650);
            var fov = 90;
            var aspect_ratio = window.innerWidth / window.innerHeight;
            var near_clipping = 0.1;
            var far_clipping = 1000;
            var camera = new THREE.PerspectiveCamera(
                fov,
                aspect_ratio,
                near_clipping,
                far_clipping
            );

            window.addEventListener("resize", function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            var autoJump = true;
            function toggleAutoJump() {
                autoJump = !autoJump;
                text = autoJump ? "Auto Jump: On":"Auto Jump: Off";
                document.getElementById("autoJumpButton").innerHTML = text;
            }
            var canFly = false;
            function toggleCanFly() {
                canFly = !canFly;
                if (!canFly) {
                    canJump = false;
                }
                movingSpeed = canFly ? FLY_MOVING_SPEED : MOVING_SPEED;
                text = canFly ? "Can Fly: On":"Can Fly: Off";
                document.getElementById("canFlyButton").innerHTML = text;
            }

            var loader = new THREE.TextureLoader();
            var materialArray = [
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-top.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-bottom.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
            ];

            const BLOCK_SIZE = 5;
            const RENDER_DISTANCE = 3;
            const CHUNK_SIZE = 16;
            class Block {
                
                constructor(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.mesh;
                    this.line;
                }

                display() {
                    const blockBox = new THREE.BoxBufferGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); // w, h, d
                    //const blockMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                    this.mesh = new THREE.Mesh(blockBox, materialArray);
                    scene.add(this.mesh);
                    this.mesh.position.x = this.x;
                    this.mesh.position.y = this.y - 10; //camera height
                    this.mesh.position.z = this.z;

                    const edges = new THREE.EdgesGeometry(blockBox);
                    this.line = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({ color: 0x006400 })
                    );
                    scene.add(this.line);
                    this.line.position.x = this.x;
                    this.line.position.y = this.y - 10; //camera height
                    this.line.position.z = this.z;
                }
            }

            var inc = 0.05;
            var amplitude = 30 + Math.random() * 30;
            function generate() {
                var chunks = [];
                var xoff = 0;
                var zoff = 0;
                var chunk = [];
                //center the camera
                camera.position.x = RENDER_DISTANCE * CHUNK_SIZE / 2 * BLOCK_SIZE;
                camera.position.z = RENDER_DISTANCE * CHUNK_SIZE / 2 * BLOCK_SIZE;
                camera.position.y = 50;
                for (var i = 0; i < RENDER_DISTANCE; ++i) {
                    for (var j = 0; j < RENDER_DISTANCE; ++j) {
                        chunk = [];
                        for (var x = i * CHUNK_SIZE; x < i * CHUNK_SIZE + CHUNK_SIZE; ++x) {
                            for (var z = j * CHUNK_SIZE; z < j * CHUNK_SIZE + CHUNK_SIZE; ++z) {
                                xoff = inc * x;
                                zoff = inc * z;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x * BLOCK_SIZE, y, z * BLOCK_SIZE));
                            }
                        }
                        chunks.push(chunk);
                    }
                }

                for (var chunk = 0; chunk < chunks.length; ++chunk) {
                    for (var block = 0; block < chunks[chunk].length; ++block) {
                        chunks[chunk][block].display();
                    }
                }

                return chunks;
            }

            terrain = generate();

            function render() {
                renderer.render(scene, camera);
            }

            var keys = [];
            var canJump = true;
            document.addEventListener("keydown", function(e) {
                keys.push(e.key);
                if (e.key == " " && canJump) { //jump
                    gravity_effect = JUMP_HEIGHT;
                    canJump = false;
                }
            });
            document.addEventListener("keyup", function(e) {
                var newArr = [];
                for (var i = 0; i < keys.length; ++i) {
                    if (keys[i] != e.key) {
                        newArr.push(keys[i]);
                    }
                }
                keys = newArr;
            });

            const controls = new THREE.PointerLockControls(camera, document.body);
            document.body.addEventListener("click", function() {
                controls.lock()
            });
            controls.addEventListener('lock', function () {});
            controls.addEventListener('unlock', function () {});

            const FLY_MOVING_SPEED = 3;
            const MOVING_SPEED = 0.7;
            const JUMP_HEIGHT = -1.3;
            var movingSpeed = MOVING_SPEED;
            var gravity_effect = 0;
            var gravity = 0.08;
            
            function update() {
                if (keys.includes("w")) {
                    controls.moveForward(movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveForward(-1 * movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.includes("a")) {
                    controls.moveRight(-1 * movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveRight(movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.includes("s")) {
                    controls.moveForward(-1 * movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveForward(movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.includes("d")) {
                    controls.moveRight(movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveRight(-1 * movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }

                if (!canFly) {
                    camera.position.y = camera.position.y - gravity_effect;
                    gravity_effect += gravity;
                } else {
                    camera.position.y = camera.position.y - gravity_effect;
                    gravity_effect = 0;
                    canJump = true;
                }

                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        // camera colliding player top of the block horizontal detection
                        // BLOCK_SIZE / 2 instead of BLOCK_SIZE because three js axis in the center of the block
                        if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                            camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                            camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                            camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                            // player under the top vertical detection
                            if (camera.position.y <= terrain[chunk][block].y + BLOCK_SIZE / 2 &&
                                camera.position.y >= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                camera.position.y = terrain[chunk][block].y + BLOCK_SIZE / 2;
                                if (!canFly) {
                                    gravity_effect = 0;
                                    canJump = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                var lowestXZ = lowestBlock();
                var highestXZ = highestBlock();
                var remove_chunk_limit = 5;
                /*
                    render distance 3 means 9 chunks
                    looking from above +y
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind decreasing z forward North
                if (camera.position.z <= lowestXZ.z + remove_chunk_limit * BLOCK_SIZE) {
                    for (var chunk = RENDER_DISTANCE - 1; chunk < terrain.length; chunk+=RENDER_DISTANCE) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            scene.remove(terrain[chunk][block].mesh);
                            scene.remove(terrain[chunk][block].line);
                        }
                    }
                    /*
                        [0][3][6]
                        [1][p][7]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        var is_last_chunks_row = (chunk + 1) % RENDER_DISTANCE == 0;
                        if (!is_last_chunks_row) {
                            new_chunks.push(terrain[chunk]);
                        }
                    }
                    /*  
                        [n][n][n]
                        [0][p][6]
                        [1][4][7]
                    */
                    // add new chunks
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        xoffset = lowestXZ.x + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var x = xoffset; x < xoffset + CHUNK_SIZE * BLOCK_SIZE; x+=BLOCK_SIZE) {
                            zoffset = lowestXZ.z - CHUNK_SIZE * BLOCK_SIZE;
                            for (var z = zoffset; z < lowestXZ.z; z+=BLOCK_SIZE) {
                                xoff = inc * x / BLOCK_SIZE;
                                zoff = inc * z / BLOCK_SIZE;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x, y, z));
                            }
                        }
                        new_chunks.splice(i * RENDER_DISTANCE, 0, chunk);
                    }

                    terrain = new_chunks;

                    for (var chunk = 0; chunk < terrain.length - RENDER_DISTANCE + 1; chunk+= RENDER_DISTANCE) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            terrain[chunk][block].display();
                        }
                    }

                }
                /*
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind increasing z backward South
                if (camera.position.z >= highestXZ.z - remove_chunk_limit * BLOCK_SIZE) {
                    for (var chunk = 0; chunk < terrain.length - RENDER_DISTANCE + 1; chunk+=RENDER_DISTANCE) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            scene.remove(terrain[chunk][block].mesh);
                            scene.remove(terrain[chunk][block].line);
                        }
                    }
                    /*
                        [1][p][7]
                        [2][5][8]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        var is_first_chunks_row = chunk % RENDER_DISTANCE == 0;
                        if (!is_first_chunks_row) {
                            new_chunks.push(terrain[chunk]);
                        }
                    }
                    /*  
                        [1][4][7]
                        [2][p][8]
                        [n][n][n]
                    */
                    // add new chunks
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        xoffset = lowestXZ.x + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var x = xoffset; x < xoffset + CHUNK_SIZE * BLOCK_SIZE; x+=BLOCK_SIZE) {
                            zoffset = highestXZ.z + BLOCK_SIZE;
                            for (var z = zoffset; z < zoffset + CHUNK_SIZE * BLOCK_SIZE; z+=BLOCK_SIZE) {
                                xoff = inc * x / BLOCK_SIZE;
                                zoff = inc * z / BLOCK_SIZE;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x, y, z));
                            }
                        }
                        new_chunks.splice(i * RENDER_DISTANCE + 2, 0, chunk);
                    }

                    terrain = new_chunks;

                    for (var chunk = RENDER_DISTANCE - 1; chunk < terrain.length; chunk+=RENDER_DISTANCE) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            terrain[chunk][block].display();
                        }
                    }
                }
                /*
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind increasing x right East
                if (camera.position.x >= highestXZ.x - remove_chunk_limit * BLOCK_SIZE) {
                    for (var chunk = 0; chunk < RENDER_DISTANCE; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            scene.remove(terrain[chunk][block].mesh);
                            scene.remove(terrain[chunk][block].line);
                        }
                    }
                    /*
                        [3][6]
                        [p][7]
                        [5][8]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = RENDER_DISTANCE; chunk < terrain.length; ++chunk) {
                        new_chunks.push(terrain[chunk]);
                    }
                    /*  
                        [3][6][n]
                        [4][p][n]
                        [5][8][n]
                    */
                    // add new chunks
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        zoffset = lowestXZ.z + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var z = zoffset; z < zoffset + CHUNK_SIZE * BLOCK_SIZE; z+=BLOCK_SIZE) {
                            xoffset = highestXZ.x + BLOCK_SIZE;
                            for (var x = xoffset; x < xoffset + CHUNK_SIZE * BLOCK_SIZE; x+=BLOCK_SIZE) {
                                xoff = inc * x / BLOCK_SIZE;
                                zoff = inc * z / BLOCK_SIZE;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x, y, z));
                            }
                        }
                        new_chunks.splice(terrain.length - (RENDER_DISTANCE - i), 0, chunk);
                    }

                    terrain = new_chunks;

                    for (var chunk = terrain.length - RENDER_DISTANCE; chunk < terrain.length; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            terrain[chunk][block].display();
                        }
                    }
                }
                /*
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind increasing x left West
                if (camera.position.x <= lowestXZ.x + remove_chunk_limit * BLOCK_SIZE) {
                    for (var chunk = terrain.length - RENDER_DISTANCE; chunk < terrain.length; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            scene.remove(terrain[chunk][block].mesh);
                            scene.remove(terrain[chunk][block].line);
                        }
                    }
                    /*
                        [0][3]
                        [1][p]
                        [2][5]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = 0; chunk < terrain.length - RENDER_DISTANCE; ++chunk) {
                        new_chunks.push(terrain[chunk]);
                    }
                    /*  
                        [n][3][6]
                        [n][p][7]
                        [n][5][8]
                    */
                    // add new chunks
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        zoffset = lowestXZ.z + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var z = zoffset; z < zoffset + CHUNK_SIZE * BLOCK_SIZE; z+=BLOCK_SIZE) {
                            xoffset = lowestXZ.x - CHUNK_SIZE * BLOCK_SIZE;
                            for (var x = xoffset; x < lowestXZ.x; x+=BLOCK_SIZE) {
                                xoff = inc * x / BLOCK_SIZE;
                                zoff = inc * z / BLOCK_SIZE;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x, y, z));
                            }
                        }
                        new_chunks.splice(i, 0, chunk);
                    }

                    terrain = new_chunks;

                    for (var chunk = 0; chunk < RENDER_DISTANCE; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            terrain[chunk][block].display();
                        }
                    }
                }
            }

            function lowestBlock() {
                var xPosArray = []
                var zPosArray = []
                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        xPosArray.push(terrain[chunk][block].x)
                        zPosArray.push(terrain[chunk][block].z)
                    }
                }

                return {'x': Math.min.apply(null, xPosArray), 'z': Math.min.apply(null, zPosArray)}
            }

            function highestBlock() {
                var xPosArray = []
                var zPosArray = []
                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        xPosArray.push(terrain[chunk][block].x)
                        zPosArray.push(terrain[chunk][block].z)
                    }
                }

                return {'x': Math.max.apply(null, xPosArray), 'z': Math.max.apply(null, zPosArray)}
            }

            function gameloop() {
                requestAnimationFrame( gameloop );
                update();
                render();
            }

            gameloop();
        </script>
    </body>
</html>