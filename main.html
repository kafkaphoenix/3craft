<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>3craft</title>
        <style>
			body { margin: 0; }
            #autoJumpButton {
                position: absolute;
                right: 20px;
                top: 20px;
            }
            #canFlyButton {
                position: absolute;
                right: 20px;
                top: 50px;
            }
            #cursor {
                position : absolute;
                width : 3%;
		    }
		</style>
    </head>
    <body>
        <button id="autoJumpButton" onclick="toggleAutoJump()">Auto Jump: Off</button>
        <button id="canFlyButton" onclick="toggleCanFly()">Can Fly: Off</button>
        <script src="js/vendor/three.js"></script>
        <script src="js/vendor/stats.js"></script>
        <script src="js/vendor/PointerLockControls.js"></script>
        <script src="js/vendor/perlin.js"></script>
        <img src = "assets/cursor.png" id = "cursor">
        <script type="text/javascript">

            var cursor = document.getElementById("cursor");
            cursor.style.left = ((0.5 * window.innerWidth) - (0.5 * cursor.width)).toString() + "px";
            cursor.style.top = ((0.5 * window.innerHeight) - (0.5 * cursor.height)).toString() + "px";

            var stats = new Stats();
            stats.showPanel(0); // 0:fps, 1:ms, 2:mb, 3+:custom
            document.body.appendChild(stats.dom);
            function showStats() {
                stats.begin();
                stats.end();
                requestAnimationFrame(showStats);
            }
            requestAnimationFrame(showStats);

            noise.seed(Math.random());
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x00ffff);
 		    scene.fog = new THREE.Fog(0x00ffff, 10, 650);
            const FOV = 90;
            var aspect_ratio = window.innerWidth / window.innerHeight;
            var near_clipping = 0.1;
            var far_clipping = 1000;
            var camera = new THREE.PerspectiveCamera(
                FOV,
                aspect_ratio,
                near_clipping,
                far_clipping
            );
            window.addEventListener("resize", function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                cursor.style.left = ((0.5 * window.innerWidth) - (0.5 * cursor.width)).toString() + "px";
 			    cursor.style.top = ((0.5 * window.innerHeight) - (0.5 * cursor.height)).toString() + "px";
            });
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const RENDER_DISTANCE = 4;
            const CHUNK_SIZE = 16;
            const BLOCK_SIZE = 5;
            const WORLD_SIZE = CHUNK_SIZE * RENDER_DISTANCE * BLOCK_SIZE;
            //center the camera
            camera.position.x = RENDER_DISTANCE * CHUNK_SIZE / 10;
            camera.position.z = RENDER_DISTANCE * CHUNK_SIZE / 10;
            camera.position.y = 50;
            const RENDER_RATIO = 0.4;

            const PLAYER_REACH = 4 * BLOCK_SIZE;
            const FLY_MOVING_SPEED = 3;
            const MOVING_SPEED = 0.8;
            const JUMP_HEIGHT = -1;
            const PLAYER_WIDTH = 0.6;
            const PLAYER_HEIGHT = 8;
            const PLAYER_DEPTH = 0.5;
            const SPRINT_SPEED = 1.5;
            var movingSpeed = MOVING_SPEED;
            var gravity_effect = 0;
            var gravity = 0.065;
            class Player {
                constructor(x, y, z, w, h, d) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.width = w;
                    this.height = h;
                    this.depth = d;
                }

                forward(speed) {
                    controls.moveForward(speed);
                    this.updatePosition();
                }

                backward(speed) {
                    controls.moveForward(-1 * speed);
                    this.updatePosition();
                }

                right(speed) {
                    controls.moveRight(speed);
                    this.updatePosition();
                }

                left(speed) {
                    controls.moveRight(-1 * speed);
                    this.updatePosition();
			    }

                updatePosition() {
                    this.x = camera.position.x;
                    this.y = camera.position.y - (this.height / 2);
                    this.z = camera.position.z;
                }

            }
            var player = new Player(
                camera.position.x,
                camera.position.y,
                camera.position.z,
                PLAYER_WIDTH,
                PLAYER_HEIGHT,
                PLAYER_DEPTH
            );


            var autoJump = false;
            var canJump = true;
            var canFly = false;
            var sprint = false;
            var keys = [];
            var SPACE = ' ';
            var controlsKeys = {
                forward: 'w',
                backward: 's',
                right: 'd',
                left: 'a',
                jump: SPACE,
                placeBlock: 'q',
                run: 'r'
            };
            function toggleAutoJump() {
                autoJump = !autoJump;
                text = autoJump ? "Auto Jump: On":"Auto Jump: Off";
                document.getElementById("autoJumpButton").innerHTML = text;
            }
            function toggleCanFly() {
                canFly = !canFly;
                if (!canFly) {
                    canJump = false;
                }
                movingSpeed = canFly ? FLY_MOVING_SPEED : MOVING_SPEED;
                text = canFly ? "Can Fly: On":"Can Fly: Off";
                document.getElementById("canFlyButton").innerHTML = text;
            }
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();
            pointer.x = (0.5) * 2 - 1;
            pointer.y = -1 * (0.5) * 2 + 1;
            document.addEventListener("keydown", function(e) {
                if (e.key == controlsKeys.run) {
                    sprint = !sprint;
                }

                keys.push(e.key);
                if (e.key == controlsKeys.jump && canJump) {
                    gravity_effect = JUMP_HEIGHT;
                    canJump = false;
                }
                if (keys.includes(controlsKeys.placeBlock)) {
                    raycaster.setFromCamera(pointer, camera);
                    var intersection = raycaster.intersectObject(instancedChunk);

                    if (intersection[0] != undefined && intersection[0].distance < PLAYER_REACH) {
                        var materialIndex = intersection[0].face.materialIndex;
                        var position = intersection[0].point; // object with x, y and z coords
                        var x = 0;
                        var y = 0;
                        var z = 0;
                        const inc = BLOCK_SIZE / 2; // offset to avoid placing the block where we are looking
                        switch(materialIndex){
                            case 0: // right
                                x = position.x + inc;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 1: // left
                                x = position.x - inc;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 2: // top
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = position.y + inc;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 3: // bottom
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = position.y - inc;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 4: // front
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = position.z + inc;
                                break;
                            case 5: // back
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = position.z - inc;
                                break;
                        }
                        y = Math.round(y); // sometimes, y is for some reason e.g 4.999999999999
                        var new_block = new Block(x, y, z, true);
                        var is_intersecting = intersect(
                            new_block.x, new_block.y, new_block.z, BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE,
                            player.x, player.y, player.z, player.width, player.height, player.depth
                        );
                        if (!is_intersecting) {
                            placedBlocks.push(new_block);
                            terrain[identifyChunk(x, z)].push(new_block);
                            rebuild_mesh();
                        }
                    }
                }
            });
            document.addEventListener("keyup", function(e) {
                var newArr = [];
                for (var i = 0; i < keys.length; ++i) {
                    if (keys[i] != e.key) {
                        newArr.push(keys[i]);
                    }
                }
                keys = newArr;
            });
            const controls = new THREE.PointerLockControls(camera, document.body);
            var brokenBlocks = [];
            document.body.addEventListener("click", function() {
                controls.lock();
                if (controls.isLocked) {
                    raycaster.setFromCamera(pointer, camera);
                    var intersection = raycaster.intersectObject(instancedChunk);

                    if (intersection[0] != undefined && intersection[0].distance < PLAYER_REACH) {
                        var materialIndex = intersection[0].face.materialIndex;
                        var position = intersection[0].point; // object with x, y and z coords
                        var x = 0;
                        var y = 0;
                        var z = 0;
                        const inc = BLOCK_SIZE / 2; //offset to center the block we want to remove
                        switch(materialIndex){
                            case 0: // right
                                x = position.x - inc;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 1: // left
                                x = position.x + inc;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 2: // top
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = position.y - inc;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 3: // bottom
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = position.y + inc;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 4: // front
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = position.z - inc;
                                break;
                            case 5: // back
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = position.z + inc;
                                break;
                        }
                        var chunk_index = identifyChunk(x, z);
                        y = Math.round(y); // sometimes, y is for some reason e.g 4.999999999999
                        var chunk = terrain[chunk_index];
                        var broken_block = getBlock(chunk, x, y, z);
                        if (broken_block.block.placed) {
                            var placed_block = getBlock(placedBlocks, x, y, z);
                            placedBlocks.splice(placed_block.index, 1); // 2nd parameter means remove one item only
                        } else { //normal block
                            brokenBlocks.push(broken_block.block);
                        }
                        terrain[chunk_index].splice(broken_block.index, 1);
                        rebuild_mesh();
                    }
                }
            });
            controls.addEventListener('lock', function () {});
            controls.addEventListener('unlock', function () {keys = [];});


            var inc = 0.05;
            var amplitude = 30 + Math.random() * 30;
            var loader = new THREE.TextureLoader();
            var materialArray = [
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-top.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-bottom.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
            ];
            var faces = [
                { // left
                    dir: [ -1*BLOCK_SIZE,  0,  0, "left"],
                },
                { // right
                    dir: [  1*BLOCK_SIZE,  0,  0, "right"],
                },
                { // bottom
                    dir: [  0, -1*BLOCK_SIZE,  0, "bottom"],
                },
                { // top
                    dir: [  0,  1*BLOCK_SIZE,  0, "top"],
                },
                { // back
                    dir: [  0,  0, -1*BLOCK_SIZE, "back"],
                },
                { // front
                    dir: [  0,  0,  1*BLOCK_SIZE, "front"],
                },
            ];
            class Block {
                constructor(x, y, z, placed) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.blocks_around = [];
                    this.placed = placed;
                }

                getXYZ() {
                    return {'x': this.x, 'y': this.y, 'z': this.z};
                }

                isVoxelHere(x, y, z) {
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            var block_pos = terrain[chunk][block].getXYZ();
                            if (block_pos.x == x && block_pos.y == y && block_pos.z == z) {
                                return true;
                            }  
                        }
                    }
                    return false;
                }

                adjustFaces() {
                    for (const {dir} of faces) {
                        const neighbour = this.isVoxelHere(this.x + dir[0], this.y + dir[1], this.z + dir[2]);
                        if (neighbour) {
                            switch(dir[3]) {
                                case "right":
                                    this.blocks_around.push("right");
                                    break;
                                case "left":
                                    this.blocks_around.push("left");
                                    break;
                                case "bottom":
                                    this.blocks_around.push("bottom");
                                    break;
                                case "top":
                                    this.blocks_around.push("top");
                                    break;
                                case "back":
                                    this.blocks_around.push("back");
                                    break;
                                case "front":
                                    this.blocks_around.push("front");
                                    break;
                            }
                        }
                    }
                }
            }

            var blockBox = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const total_meshes = CHUNK_SIZE * CHUNK_SIZE * RENDER_DISTANCE * RENDER_DISTANCE;
            var instancedChunk = new THREE.InstancedMesh(blockBox, materialArray, total_meshes);
            function generate() {
                var chunks = [];
                var xoff = 0;
                var zoff = 0;
                var chunk = [];
                var count = 0;
                for (var i = 0; i < RENDER_DISTANCE; ++i) {
                    for (var j = 0; j < RENDER_DISTANCE; ++j) {
                        chunk = [];
                        for (var x = i * CHUNK_SIZE; x < i * CHUNK_SIZE + CHUNK_SIZE; ++x) {
                            for (var z = j * CHUNK_SIZE; z < j * CHUNK_SIZE + CHUNK_SIZE; ++z) {
                                xoff = inc * x;
                                zoff = inc * z;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x * BLOCK_SIZE, y, z * BLOCK_SIZE, false));
                                let matrix = new THREE.Matrix4().makeTranslation(x * BLOCK_SIZE, y, z * BLOCK_SIZE);
                                instancedChunk.setMatrixAt(count, matrix);
                                ++count;
                            }
                        }
                        chunks.push(chunk);
                    }
                }
                scene.add(instancedChunk);

                return chunks;
            }
            terrain = generate();
            var placedBlocks = [];
            var chunkMap = [];
            for (var x = 0; x < RENDER_DISTANCE; ++x) {
                for (var z = 0; z < RENDER_DISTANCE; ++z) {
                    chunkMap.push({x: x, z: z});
                }
            }

            var plane;
            function render() {
                raycaster.setFromCamera(pointer, camera);
                var intersection = raycaster.intersectObject(instancedChunk);
                if (intersection[0] && intersection[0].distance < PLAYER_REACH) {
                    if (!scene.children.includes(plane)) {
                        var planeG = new THREE.PlaneGeometry(BLOCK_SIZE, BLOCK_SIZE);
                        var planeM = new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide});
                        planeM.transparent = true;
                        planeM.opacity = 0.5;
                        plane = new THREE.Mesh(planeG, planeM);
                        scene.add(plane);
                    } else {
                    	plane.visible = true;
                        var materialIndex = intersection[0].face.materialIndex;
                        var position = intersection[0].point; // object with x, y and z coords
                        var x = 0;
                        var y = 0;
                        var z = 0;
                        const inc = 0.1; 
                        switch(materialIndex){
                            case 0: // right
                                plane.rotation.x = 0;
                                plane.rotation.y = (Math.PI / 2);
                                plane.rotation.z = 0;
                                x = position.x + inc;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 1: // left
                                plane.rotation.x = 0;
                                plane.rotation.y = (Math.PI / 2);
                                plane.rotation.z = 0;
                                x = position.x - inc;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 2: // top
                                plane.rotation.x = (Math.PI / 2);
                                plane.rotation.y = 0;
                                plane.rotation.z = 0;
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = position.y + inc;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 3: // bottom
                                plane.rotation.x = (Math.PI / 2);
                                plane.rotation.y = 0;
                                plane.rotation.z = 0;
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = position.y - inc;
                                z = Math.round(position.z / BLOCK_SIZE) * BLOCK_SIZE;
                                break;
                            case 4: // front
                                plane.rotation.x = 0;
                                plane.rotation.y = 0;
                                plane.rotation.z = 0;
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = position.z + inc;
                                break;
                            case 5: // back
                                plane.rotation.x = 0;
                                plane.rotation.y = 0;
                                plane.rotation.z = 0;
                                x = Math.round(position.x / BLOCK_SIZE) * BLOCK_SIZE;
                                y = Math.round(position.y / BLOCK_SIZE) * BLOCK_SIZE;
                                z = position.z - inc;
                                break;
                        }
                        plane.position.x = x;
                        plane.position.y = y;
                        plane.position.z = z;
                    }
                } else {
                    if (plane) {
                        plane.visible = false;
                    }
                }

                renderer.render(scene, camera);
            }


            var deceleration = 1.35;
            var forback = 0; // 1 = forward, -1 = backward
		    var rightleft = 0; // 1 = right, -1 = left
            function update() {
                player.updatePosition();
                if (keys.includes(controlsKeys.forward)) {
                    var velocity = movingSpeed * (sprint ? SPRINT_SPEED : 1);
                    player.forward(velocity);
                    forback = 1 * movingSpeed;
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                var check_block = terrain[chunk][block];
                                var condition = (check_block.y - (BLOCK_SIZE / 2) < player.y + (player.height / 2) && check_block.y + (BLOCK_SIZE / 2) > player.y - (player.height / 2));
                                var is_intersecting = intersect(
                                    check_block.x, check_block.y, check_block.z, BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE,
                                    player.x, player.y, player.z, player.width, player.height, player.depth
                                );
                                if (is_intersecting && condition) {
                                    player.backward(velocity);
                                    forback = 0;
                                    rightleft = 0;
                                    sprint = false;
                                }
                            }
                        }
                    }
                }
                if (keys.includes(controlsKeys.backward)) {
                    var velocity = movingSpeed * (sprint ? SPRINT_SPEED : 1);
                    player.backward(velocity);
                    forback = -1 * movingSpeed;
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                var check_block = terrain[chunk][block];
                                var condition = (check_block.y - (BLOCK_SIZE / 2) < player.y + (player.height / 2) && check_block.y + (BLOCK_SIZE / 2) > player.y - (player.height / 2));
                                var is_intersecting = intersect(
                                    check_block.x, check_block.y, check_block.z, BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE,
                                    player.x, player.y, player.z, player.width, player.height, player.depth
                                );
                                if (is_intersecting && condition) {
                                    player.forward(velocity);
                                    forback = 0;
                                    rightleft = 0;
                                    sprint = false;
                                }
                            }
                        }
                    }
                }
                if (keys.includes(controlsKeys.left)) {
                    var velocity = movingSpeed * (sprint ? SPRINT_SPEED : 1);
                    player.left(velocity);
                    rightleft = -1 * movingSpeed;
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                var check_block = terrain[chunk][block];
                                var condition = (check_block.y - (BLOCK_SIZE / 2) < player.y + (player.height / 2) && check_block.y + (BLOCK_SIZE / 2) > player.y - (player.height / 2));
                                var is_intersecting = intersect(
                                    check_block.x, check_block.y, check_block.z, BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE,
                                    player.x, player.y, player.z, player.width, player.height, player.depth
                                );
                                if (is_intersecting && condition) {
                                    player.right(velocity);
                                    forback = 0;
                                    rightleft = 0;
                                    sprint = false;
                                }
                            }
                        }
                    }
                }
                if (keys.includes(controlsKeys.right)) {
                    var velocity = movingSpeed * (sprint ? SPRINT_SPEED : 1);
                    player.right(velocity);
                    rightleft = 1 * movingSpeed;
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                var check_block = terrain[chunk][block];
                                var condition = (check_block.y - (BLOCK_SIZE / 2) < player.y + (player.height / 2) && check_block.y + (BLOCK_SIZE / 2) > player.y - (player.height / 2));
                                var is_intersecting = intersect(
                                    check_block.x, check_block.y, check_block.z, BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE,
                                    player.x, player.y, player.z, player.width, player.height, player.depth
                                );
                                if (is_intersecting && condition) {
                                    player.left(velocity);
                                    forback = 0;
                                    rightleft = 0;
                                    sprint = false;
                                }
                            }
                        }
                    }
                }

                // Deceleration part
                if (!keys.includes(controlsKeys.forward) && !keys.includes(controlsKeys.backward) && !keys.includes(controlsKeys.right) && !keys.includes(controlsKeys.left)) {
                    forback /= deceleration;
                    rightleft /= deceleration;
                    var br = false;
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            var check_block = terrain[chunk][block];
                            var condition = (check_block.y - (BLOCK_SIZE / 2) < player.y + (player.height / 2) && check_block.y + (BLOCK_SIZE / 2) > player.y - (player.height / 2));
                            var is_intersecting = intersect(
                                check_block.x, check_block.y, check_block.z, BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE,
                                player.x, player.y, player.z, player.width, player.height, player.depth
                            );
                            if(is_intersecting && condition){
                                br = true;
                                forback /= -deceleration;
                                rightleft /= -deceleration;
                                sprint = false;
                                break;
                            }
                        }
                        if(br){
                            break;
                        }
                    }
                    player.forward(forback * (sprint ? SPRINT_SPEED : 1));
                    player.right(rightleft * (sprint ? SPRINT_SPEED : 1));
                }

                if (!canFly) {
                    camera.position.y = camera.position.y - gravity_effect;
                    gravity_effect += gravity;
                } else {
                    camera.position.y = camera.position.y - gravity_effect;
                    gravity_effect = 0;
                    canJump = true;
                }

                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        // BLOCK_SIZE / 2 instead of BLOCK_SIZE because three js axis in the center of the block
                        // player falling through a block
                        var check_block = terrain[chunk][block];
                        var below_block = camera.position.y <= check_block.y + BLOCK_SIZE / 2 + player.height && camera.position.y >= check_block.y;
                        var is_intersecting = intersect(
                            check_block.x, check_block.y + 2 * BLOCK_SIZE, check_block.z, BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE,
                            player.x, player.y, player.z, player.width, player.height, player.depth
                        );
                        if (is_intersecting && below_block) {
                                // set player above terrain
                                camera.position.y = check_block.y + (BLOCK_SIZE / 2) + player.height;
                                if (!canFly) {
                                    gravity_effect = 0;
                                    canJump = true;
                                }
                            }
                        // player jump and head touch the ceiling
                        var is_intersecting = intersect(
                            check_block.x, check_block.y, check_block.z, BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE,
                            player.x, player.y, player.z, player.width, player.height, player.depth
                        );
                        var above_block = camera.position.y >= check_block.y - (BLOCK_SIZE / 2) && camera.position.y <= check_block.y;
                        if (is_intersecting && above_block) {
                            gravity_effect = 0.8; // go down to avoid
                        }
                    }
                }

                /*
                    render distance 3 means 9 chunks
                    looking from above +y
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind decreasing z forward North
                var lowestXZ = lowestBlock();
                if (camera.position.z < lowestXZ.z + WORLD_SIZE * RENDER_RATIO) {
                    /*
                        [0][3][6]
                        [1][p][7]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        var is_last_chunks_row = (chunk + 1) % RENDER_DISTANCE == 0;
                        if (!is_last_chunks_row) {
                            new_chunks.push(terrain[chunk]);
                        }
                    }
                    /*  
                        [n][n][n]
                        [0][p][6]
                        [1][4][7]
                    */
                    // add new chunks
                    var lowestXZ = lowestBlock();
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        var xoffset = lowestXZ.x + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var x = xoffset; x < xoffset + CHUNK_SIZE * BLOCK_SIZE; x+=BLOCK_SIZE) {
                            var zoffset = lowestXZ.z - CHUNK_SIZE * BLOCK_SIZE;
                            for (var z = zoffset; z < lowestXZ.z; z+=BLOCK_SIZE) {
                                update_mesh(chunk, x, z);
                            }
                        }
                        new_chunks.splice(i * RENDER_DISTANCE, 0, chunk);
                    }
                    terrain = new_chunks;
                    rebuild_mesh();
                }
                /*
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind increasing z backward South
                var highestXZ = highestBlock();
                if (camera.position.z > highestXZ.z - WORLD_SIZE * RENDER_RATIO) {
                    /*
                        [1][p][7]
                        [2][5][8]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        var is_first_chunks_row = chunk % RENDER_DISTANCE == 0;
                        if (!is_first_chunks_row) {
                            new_chunks.push(terrain[chunk]);
                        }
                    }
                    /*  
                        [1][4][7]
                        [2][p][8]
                        [n][n][n]
                    */
                    // add new chunks
                    var lowestXZ = lowestBlock();
                    var highestXZ = highestBlock();
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        var xoffset = lowestXZ.x + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var x = xoffset; x < xoffset + CHUNK_SIZE * BLOCK_SIZE; x+=BLOCK_SIZE) {
                            var zoffset = highestXZ.z + BLOCK_SIZE;
                            for (var z = zoffset; z < zoffset + CHUNK_SIZE * BLOCK_SIZE; z+=BLOCK_SIZE) {
                                update_mesh(chunk, x, z);
                            }
                        }
                        new_chunks.splice((i + 1) * RENDER_DISTANCE - 1, 0, chunk);
                    }
                    terrain = new_chunks;
                    rebuild_mesh();
                }
                /*
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind increasing x right East
                var highestXZ = highestBlock();
                if (camera.position.x > highestXZ.x - WORLD_SIZE * RENDER_RATIO) {
                    /*
                        [3][6]
                        [p][7]
                        [5][8]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = RENDER_DISTANCE; chunk < terrain.length; ++chunk) {
                        new_chunks.push(terrain[chunk]);
                    }
                    /*  
                        [3][6][n]
                        [4][p][n]
                        [5][8][n]
                    */
                    // add new chunks
                    var lowestXZ = lowestBlock();
                    var highestXZ = highestBlock();
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        var zoffset = lowestXZ.z + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var z = zoffset; z < zoffset + CHUNK_SIZE * BLOCK_SIZE; z+=BLOCK_SIZE) {
                            var xoffset = highestXZ.x + BLOCK_SIZE;
                            for (var x = xoffset; x < xoffset + CHUNK_SIZE * BLOCK_SIZE; x+=BLOCK_SIZE) {
                                update_mesh(chunk, x, z);
                            }
                        }
                        new_chunks.splice(terrain.length - (RENDER_DISTANCE - i), 0, chunk);
                    }
                    terrain = new_chunks;
                    rebuild_mesh();
                }
                /*
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind increasing x left West
                var lowestXZ = lowestBlock();
                if (camera.position.x < lowestXZ.x + WORLD_SIZE * RENDER_RATIO) {
                    /*
                        [0][3]
                        [1][p]
                        [2][5]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = 0; chunk < terrain.length - RENDER_DISTANCE; ++chunk) {
                        new_chunks.push(terrain[chunk]);
                    }
                    /*  
                        [n][3][6]
                        [n][p][7]
                        [n][5][8]
                    */
                    // add new chunks
                    var lowestXZ = lowestBlock();
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        var zoffset = lowestXZ.z + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var z = zoffset; z < zoffset + CHUNK_SIZE * BLOCK_SIZE; z+=BLOCK_SIZE) {
                            var xoffset = lowestXZ.x - CHUNK_SIZE * BLOCK_SIZE;
                            for (var x = xoffset; x < lowestXZ.x; x+=BLOCK_SIZE) {
                                update_mesh(chunk, x, z);
                            }
                        }
                        new_chunks.splice(i, 0, chunk);
                    }
                    terrain = new_chunks;
                    rebuild_mesh();
                }
            }

            const arrayMin = (arr) => arr.reduce(([min], val) => [Math.min(min, val)], [Number.POSITIVE_INFINITY]);
            const arrayMax = (arr) => arr.reduce(([max], val) => [Math.max(max, val)], [Number.NEGATIVE_INFINITY]);
            function lowestBlock() {
                var xPosArray = [];
                var zPosArray = [];
                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        xPosArray.push(terrain[chunk][block].x);
                        zPosArray.push(terrain[chunk][block].z);
                    }
                }
                min_x = arrayMin(xPosArray);
                min_z = arrayMin(zPosArray);

                return {'x': min_x[0], 'z': min_z[0]};
            }
            function highestBlock() {
                var xPosArray = [];
                var zPosArray = [];
                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        xPosArray.push(terrain[chunk][block].x);
                        zPosArray.push(terrain[chunk][block].z);
                    }
                }

                max_x = arrayMax(xPosArray);
                max_z = arrayMax(zPosArray);

                return {'x': max_x[0], 'z': max_z[0]};
            }

            function add_player_structures(chunk, x, z) {
                // Check if there is also a placed block there
                for (var block = 0; block < placedBlocks.length; ++block) {
                    placed_block = placedBlocks[block];
                    if (placed_block.x == x && placed_block.z == z) {
                        chunk.push(new Block(placed_block.x, placed_block.y, placed_block.z, true));
                    }
                }
            }

            function identifyChunk(x, z) {
                var lowestXZ = lowestBlock();
                var difX = x - lowestXZ.x;
                var difZ = z - lowestXZ.z;
                var divX = Math.floor(difX / (CHUNK_SIZE * BLOCK_SIZE));
                var divZ = Math.floor(difZ / (CHUNK_SIZE * BLOCK_SIZE));
                var index = undefined;
                var i = 0;
                while (index == undefined && i < chunkMap.length) {
                    if (chunkMap[i].x == divX && chunkMap[i].z == divZ) {
                        index = i;
                    }
                    ++i;
                }

                return index;
            }

            function getBlock(space, x, y, z) {
                var looked_block = undefined;
                var block = 0;
                while (looked_block == undefined && block < space.length) {
                    block_pos = space[block].getXYZ();
                    if (block_pos.x == x && block_pos.y == y && block_pos.z == z) {
                        looked_block = space[block];
                    } else {
                        ++block;
                    }
                }

                return {'block': looked_block, 'index': block};
            }

            function update_mesh(chunk, x, z) {
                var xoff = inc * x / BLOCK_SIZE;
                var zoff = inc * z / BLOCK_SIZE;
                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                var broken_block = getBlock(brokenBlocks, x, y, z);
                if (broken_block.block == undefined) {
                    chunk.push(new Block(x, y, z, false));
                }
                add_player_structures(chunk, x, z);
            }

            function rebuild_mesh() {
                scene.remove(instancedChunk);
                var placed_meshes = placedBlocks.length;
                instancedChunk = new THREE.InstancedMesh(blockBox, materialArray, total_meshes + placed_meshes);
                var count = 0;
                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        let matrix = new THREE.Matrix4().makeTranslation(
                            terrain[chunk][block].x,
                            terrain[chunk][block].y,
                            terrain[chunk][block].z
                        );
                        instancedChunk.setMatrixAt(count, matrix);
                        ++count;
                    }
                }
                scene.add(instancedChunk);
            }

            function intersect(x1, y1, z1, w1, h1, d1, x2, y2, z2, w2, h2, d2){
                var a = {
                    minX : x1 - (w1/2),
                    maxX : x1 + (w1/2),
                    minZ : z1 - (d1/2),
                    maxZ : z1 + (d1/2),
                    minY : y1 - (h1/2),
                    maxY : y1 + (h1/2),
                };
                var b = {
                    minX : x2 - (w2/2),
                    maxX : x2 + (w2/2),
                    minZ : z2 - (d2/2),
                    maxZ : z2 + (d2/2),
                    minY : y2 - (h2/2),
                    maxY : y2 + (h2/2),
                };
                return (a.minX <= b.maxX && a.maxX >= b.minX) &&
                    (a.minY <= b.maxY && a.maxY >= b.minY) &&
                    (a.minZ <= b.maxZ && a.maxZ >= b.minZ);
		    }

            function gameloop() {
                requestAnimationFrame(gameloop);
                update();
                render();
            }

            gameloop();
        </script>
    </body>
</html>