<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>3craft</title>
        <style>
			body { margin: 0; }
            #autoJumpButton {
                position: absolute;
                left: 20px;
                top: 20px;
            }
		</style>
    </head>
    <body>
        <button id="autoJumpButton" onclick="toggleAutoJump()">Auto Jump: On</button>
        <script src="js/vendor/three.js"></script>
        <script src="js/vendor/PointerLockControls.js"></script>
        <script src="js/vendor/perlin.js"></script>
        <script type="text/javascript">
            noise.seed(Math.random())
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x00ffff);
 		    scene.fog = new THREE.Fog(0x00ffff, 10, 650);
            var fov = 90;
            var aspect_ratio = window.innerWidth / window.innerHeight;
            var near_clipping = 0.1;
            var far_clipping = 1000;
            var camera = new THREE.PerspectiveCamera(
                fov,
                aspect_ratio,
                near_clipping,
                far_clipping
            );

            window.addEventListener("resize", function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            var autoJump = true;
            function toggleAutoJump() {
                autoJump = !autoJump;
                text = autoJump ? "Auto Jump: On":"Auto Jump: Off";
                document.getElementById("autoJumpButton").innerHTML = text;
            }

            var loader = new THREE.TextureLoader();
            var materialArray = [
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-top.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-bottom.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
            ];

            const BLOCK_SIZE = 5;
            const RENDER_DISTANCE = 3;
            const CHUNK_SIZE = 16;
            class Block {
                
                constructor(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }

                display() {
                    const blockBox = new THREE.BoxBufferGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); // w, h, d
                    //const blockMesh = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                    const block = new THREE.Mesh(blockBox, materialArray);
                    scene.add(block);
                    block.position.x = this.x;
                    block.position.y = this.y - 10; //camera height
                    block.position.z = this.z;

                    const edges = new THREE.EdgesGeometry(blockBox);
                    const line = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({ color: 0x006400 })
                    );
                    scene.add(line);
                    line.position.x = this.x;
                    line.position.y = this.y - 10; //camera height
                    line.position.z = this.z;
                }
            }

            function generate() {
                var chunks = [];
                var xoff = 0;
                var zoff = 0;
                var inc = 0.05;
                var amplitude = 30 + Math.random() * 70;
                var chunk = [];
                //center the camera
                camera.position.x = RENDER_DISTANCE * CHUNK_SIZE / 2 * BLOCK_SIZE;
                camera.position.z = RENDER_DISTANCE * CHUNK_SIZE / 2 * BLOCK_SIZE;
                camera.position.y = 50;
                for (var i = 0; i < RENDER_DISTANCE; ++i) {
                    for (var j = 0; j < RENDER_DISTANCE; ++j) {
                        chunk = [];
                        for (var x = i * CHUNK_SIZE; x < i * CHUNK_SIZE + CHUNK_SIZE; ++x) {
                            for (var z = j * CHUNK_SIZE; z < j * CHUNK_SIZE + CHUNK_SIZE; ++z) {
                                xoff = inc * x;
                                zoff = inc * z;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x * BLOCK_SIZE, y, z * BLOCK_SIZE));
                            }
                        }
                        chunks.push(chunk);
                    }
                }

                for (var chunk = 0; chunk < chunks.length; ++chunk) {
                    for (var block = 0; block < chunks[chunk].length; ++block) {
                        chunks[chunk][block].display();
                    }
                }

                return chunks;
            }

            terrain = generate();

            function render() {
                renderer.render(scene, camera);
            }

            var keys = [];
            var canJump = true;
            document.addEventListener("keydown", function(e) {
                keys.push(e.key);
                if (e.key == " " && canJump) { //jump
                    ySpeed = -1.3;
                    canJump = false;
                }
            });
            document.addEventListener("keyup", function(e) {
                var newArr = [];
                for (var i = 0; i < keys.length; ++i) {
                    if (keys[i] != e.key) {
                        newArr.push(keys[i]);
                    }
                }
                keys = newArr;
            });

            const controls = new THREE.PointerLockControls(camera, document.body);
            document.body.addEventListener("click", function() {
                controls.lock()
            });
            controls.addEventListener('lock', function () {});
            controls.addEventListener('unlock', function () {});

            var movingSpeed = 0.7;
            var ySpeed = 0;
            var acc = 0.08;
            
            function update() {
                if (keys.includes("w")) {
                    controls.moveForward(movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveForward(-1 * movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.includes("a")) {
                    controls.moveRight(-1 * movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveRight(movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.includes("s")) {
                    controls.moveForward(-1 * movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveForward(movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.includes("d")) {
                    controls.moveRight(movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveRight(-1 * movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }

                camera.position.y = camera.position.y - ySpeed;
                ySpeed += acc;

                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        // camera colliding player top of the block horizontal detection
                        // BLOCK_SIZE / 2 instead of BLOCK_SIZE because three js axis in the center of the block
                        if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                            camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                            camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                            camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                            // player under the top vertical detection
                            if (camera.position.y <= terrain[chunk][block].y + BLOCK_SIZE / 2 &&
                                camera.position.y >= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                camera.position.y = terrain[chunk][block].y + BLOCK_SIZE / 2;
                                ySpeed = 0;
                                canJump = true;
                                break;
                            }
                        }
                    }
                }
            }

            function gameloop() {
                requestAnimationFrame( gameloop );
                update();
                render();
            }

            gameloop();
        </script>
    </body>
</html>