<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>3craft</title>
        <style>
			body { margin: 0; }
            #autoJumpButton {
                position: absolute;
                right: 20px;
                top: 20px;
            }
            #canFlyButton {
                position: absolute;
                right: 20px;
                top: 42px;
            }
		</style>
    </head>
    <body>
        <button id="autoJumpButton" onclick="toggleAutoJump()">Auto Jump: On</button>
        <button id="canFlyButton" onclick="toggleCanFly()">Can Fly: Off</button>
        <script src="js/vendor/three.js"></script>
        <script src="js/vendor/stats.js"></script>
        <script src="js/vendor/PointerLockControls.js"></script>
        <script src="js/vendor/perlin.js"></script>
        <script type="text/javascript">

            var stats = new Stats();
            stats.showPanel(0); // 0:fps, 1:ms, 2:mb, 3+:custom
            document.body.appendChild(stats.dom);

            function showStats() {
                stats.begin();
                stats.end();
                requestAnimationFrame(showStats);
            }
            requestAnimationFrame(showStats);

            noise.seed(Math.random());

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x00ffff);
 		    scene.fog = new THREE.Fog(0x00ffff, 10, 650);
            var fov = 90;
            var aspect_ratio = window.innerWidth / window.innerHeight;
            var near_clipping = 0.1;
            var far_clipping = 1000;
            var camera = new THREE.PerspectiveCamera(
                fov,
                aspect_ratio,
                near_clipping,
                far_clipping
            );

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener("resize", function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });
            
            const FLY_MOVING_SPEED = 3;
            const MOVING_SPEED = 0.7;
            const JUMP_HEIGHT = -1.3;
            var movingSpeed = MOVING_SPEED;
            var gravity_effect = 0;
            var gravity = 0.08;
            var autoJump = true;
            var canJump = true;
            var canFly = false;
            var keys = [];

            function toggleAutoJump() {
                autoJump = !autoJump;
                text = autoJump ? "Auto Jump: On":"Auto Jump: Off";
                document.getElementById("autoJumpButton").innerHTML = text;
            }

            function toggleCanFly() {
                canFly = !canFly;
                if (!canFly) {
                    canJump = false;
                }
                movingSpeed = canFly ? FLY_MOVING_SPEED : MOVING_SPEED;
                text = canFly ? "Can Fly: On":"Can Fly: Off";
                document.getElementById("canFlyButton").innerHTML = text;
            }

            document.addEventListener("keydown", function(e) {
                keys.push(e.key);
                const SPACE = " ";
                if (e.key == SPACE && canJump) { //jump
                    gravity_effect = JUMP_HEIGHT;
                    canJump = false;
                }
            });
            document.addEventListener("keyup", function(e) {
                var newArr = [];
                for (var i = 0; i < keys.length; ++i) {
                    if (keys[i] != e.key) {
                        newArr.push(keys[i]);
                    }
                }
                keys = newArr;
            });

            const controls = new THREE.PointerLockControls(camera, document.body);
            document.body.addEventListener("click", function() {
                controls.lock();
            });
            controls.addEventListener('lock', function () {});
            controls.addEventListener('unlock', function () {});

            var loader = new THREE.TextureLoader();

            var inc = 0.05;
            var amplitude = 20 + Math.random() * 30;
            const BLOCK_SIZE = 5;
            const RENDER_DISTANCE = 3;
            const CHUNK_SIZE = 16;

            var materialArray = [
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-top.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-bottom.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
                new THREE.MeshBasicMaterial({map : loader.load("assets/textures/dirt-face.jpg")}),
            ];
            var faces = [
                { // left
                    dir: [ -1*BLOCK_SIZE,  0,  0, "left"],
                },
                { // right
                    dir: [  1*BLOCK_SIZE,  0,  0, "right"],
                },
                { // bottom
                    dir: [  0, -1*BLOCK_SIZE,  0, "bottom"],
                },
                { // top
                    dir: [  0,  1*BLOCK_SIZE,  0, "top"],
                },
                { // back
                    dir: [  0,  0, -1*BLOCK_SIZE, "back"],
                },
                { // front
                    dir: [  0,  0,  1*BLOCK_SIZE, "front"],
                },
            ];

            class Block {
                constructor(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.blocks_around = [];
                }

                getXYZ() {
                    return {'x': this.x, 'y': this.y, 'z': this.z};
                }

                isVoxelHere(x, y, z) {
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            var block_pos = terrain[chunk][block].getXYZ();
                            if (block_pos.x == x && block_pos.y == y && block_pos.z == z) {
                                return true;
                            }  
                        }
                    }
                    return false;
                }

                adjustFaces() {
                    for (const {dir} of faces) {
                        const neighbour = this.isVoxelHere(this.x + dir[0], this.y + dir[1], this.z + dir[2]);
                        if (neighbour) {
                            switch(dir[3]) {
                                case "right":
                                    this.blocks_around.push("right");
                                    break;
                                case "left":
                                    this.blocks_around.push("left");
                                    break;
                                case "bottom":
                                    this.blocks_around.push("bottom");
                                    break;
                                case "top":
                                    this.blocks_around.push("top");
                                    break;
                                case "back":
                                    this.blocks_around.push("back");
                                    break;
                                case "front":
                                    this.blocks_around.push("front");
                                    break;
                            }
                        }
                    }
                }
            }

            var blockBox = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const total_meshes = CHUNK_SIZE * CHUNK_SIZE * RENDER_DISTANCE * RENDER_DISTANCE;
            var instancedChunk = new THREE.InstancedMesh(blockBox, materialArray, total_meshes);
            function generate() {
                var chunks = [];
                var xoff = 0;
                var zoff = 0;
                var chunk = [];
                //center the camera
                camera.position.x = RENDER_DISTANCE * CHUNK_SIZE / 2 * BLOCK_SIZE;
                camera.position.z = RENDER_DISTANCE * CHUNK_SIZE / 2 * BLOCK_SIZE;
                camera.position.y = 50;
                var count = 0;
                for (var i = 0; i < RENDER_DISTANCE; ++i) {
                    for (var j = 0; j < RENDER_DISTANCE; ++j) {
                        chunk = [];
                        for (var x = i * CHUNK_SIZE; x < i * CHUNK_SIZE + CHUNK_SIZE; ++x) {
                            for (var z = j * CHUNK_SIZE; z < j * CHUNK_SIZE + CHUNK_SIZE; ++z) {
                                xoff = inc * x;
                                zoff = inc * z;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x * BLOCK_SIZE, y, z * BLOCK_SIZE));
                                let matrix = new THREE.Matrix4().makeTranslation(x * BLOCK_SIZE, y, z * BLOCK_SIZE);
                                instancedChunk.setMatrixAt(count, matrix);
                                ++count;
                            }
                        }
                        chunks.push(chunk);
                    }
                }
                scene.add(instancedChunk);

                return chunks;
            }

            terrain = generate();

            function render() {
                renderer.render(scene, camera);
            }
            
            function update() {
                if (keys.includes("w")) {
                    controls.moveForward(movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveForward(-1 * movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.includes("a")) {
                    controls.moveRight(-1 * movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveRight(movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.includes("s")) {
                    controls.moveForward(-1 * movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveForward(movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.includes("d")) {
                    controls.moveRight(movingSpeed);
                    if (!autoJump) {
                        for (var chunk = 0; chunk < terrain.length; ++chunk) {
                            for (var block = 0; block < terrain[chunk].length; ++block) {
                                if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                                    camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                                    camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                                    camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                                    if (camera.position.y <= terrain[chunk][block].y - BLOCK_SIZE / 2) {
                                        controls.moveRight(-1 * movingSpeed);
                                    }
                                }
                            }
                        }
                    }
                }

                if (!canFly) {
                    camera.position.y = camera.position.y - gravity_effect;
                    gravity_effect += gravity;
                } else {
                    camera.position.y = camera.position.y - gravity_effect;
                    gravity_effect = 0;
                    canJump = true;
                }

                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        // camera colliding player top of the block horizontal detection
                        // BLOCK_SIZE / 2 instead of BLOCK_SIZE because three js axis in the center of the block
                        if (camera.position.x <= terrain[chunk][block].x + BLOCK_SIZE / 2 && 
                            camera.position.x >= terrain[chunk][block].x - BLOCK_SIZE / 2 && 
                            camera.position.z <= terrain[chunk][block].z + BLOCK_SIZE / 2 && 
                            camera.position.z >= terrain[chunk][block].z - BLOCK_SIZE / 2) {
                            // player under the top vertical detection
                            if (camera.position.y <= terrain[chunk][block].y + 2 * BLOCK_SIZE &&
                                camera.position.y >= terrain[chunk][block].y) {
                                camera.position.y = terrain[chunk][block].y + 2 * BLOCK_SIZE;
                                if (!canFly) {
                                    gravity_effect = 0;
                                    canJump = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                const remove_chunk_threshold = 5;
                var lowestXZ = lowestBlock();
                /*
                    render distance 3 means 9 chunks
                    looking from above +y
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind decreasing z forward North
                if (camera.position.z <= lowestXZ.z + remove_chunk_threshold * BLOCK_SIZE) {
                    /*
                        [0][3][6]
                        [1][p][7]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        var is_last_chunks_row = (chunk + 1) % RENDER_DISTANCE == 0;
                        if (!is_last_chunks_row) {
                            new_chunks.push(terrain[chunk]);
                        }
                    }
                    /*  
                        [n][n][n]
                        [0][p][6]
                        [1][4][7]
                    */
                    // add new chunks
                    var lowestXZ = lowestBlock();
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        xoffset = lowestXZ.x + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var x = xoffset; x < xoffset + CHUNK_SIZE * BLOCK_SIZE; x+=BLOCK_SIZE) {
                            zoffset = lowestXZ.z - CHUNK_SIZE * BLOCK_SIZE;
                            for (var z = zoffset; z < lowestXZ.z; z+=BLOCK_SIZE) {
                                xoff = inc * x / BLOCK_SIZE;
                                zoff = inc * z / BLOCK_SIZE;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x, y, z));
                            }
                        }
                        new_chunks.splice(i * RENDER_DISTANCE, 0, chunk);
                    }
                    terrain = new_chunks;
                    scene.remove(instancedChunk);
                    // reconstruct instanced mesh
                    instancedChunk = new THREE.InstancedMesh(blockBox, materialArray, total_meshes);
                    var count = 0;
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            let matrix = new THREE.Matrix4().makeTranslation(
                                terrain[chunk][block].x,
                                terrain[chunk][block].y,
                                terrain[chunk][block].z
                            );
                            instancedChunk.setMatrixAt(count, matrix);
                            ++count;
                        }
                    }
                    scene.add(instancedChunk);
                }
                var highestXZ = highestBlock();
                /*
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind increasing z backward South
                if (camera.position.z >= highestXZ.z - remove_chunk_threshold * BLOCK_SIZE) {
                    /*
                        [1][p][7]
                        [2][5][8]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        var is_first_chunks_row = chunk % RENDER_DISTANCE == 0;
                        if (!is_first_chunks_row) {
                            new_chunks.push(terrain[chunk]);
                        }
                    }
                    /*  
                        [1][4][7]
                        [2][p][8]
                        [n][n][n]
                    */
                    // add new chunks
                    var lowestXZ = lowestBlock();
                    var highestXZ = highestBlock();
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        xoffset = lowestXZ.x + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var x = xoffset; x < xoffset + CHUNK_SIZE * BLOCK_SIZE; x+=BLOCK_SIZE) {
                            zoffset = highestXZ.z + BLOCK_SIZE;
                            for (var z = zoffset; z < zoffset + CHUNK_SIZE * BLOCK_SIZE; z+=BLOCK_SIZE) {
                                xoff = inc * x / BLOCK_SIZE;
                                zoff = inc * z / BLOCK_SIZE;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x, y, z));
                            }
                        }
                        new_chunks.splice((i + 1) * RENDER_DISTANCE - 1, 0, chunk);
                    }
                    terrain = new_chunks;
                    scene.remove(instancedChunk);
                    // reconstruct instanced mesh
                    instancedChunk = new THREE.InstancedMesh(blockBox, materialArray, total_meshes);
                    var count = 0;
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            let matrix = new THREE.Matrix4().makeTranslation(
                                terrain[chunk][block].x,
                                terrain[chunk][block].y,
                                terrain[chunk][block].z
                            );
                            instancedChunk.setMatrixAt(count, matrix);
                            ++count;
                        }
                    }
                    scene.add(instancedChunk);
                }
                var highestXZ = highestBlock();
                /*
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind increasing x right East
                if (camera.position.x >= highestXZ.x - remove_chunk_threshold * BLOCK_SIZE) {
                    /*
                        [3][6]
                        [p][7]
                        [5][8]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = RENDER_DISTANCE; chunk < terrain.length; ++chunk) {
                        new_chunks.push(terrain[chunk]);
                    }
                    /*  
                        [3][6][n]
                        [4][p][n]
                        [5][8][n]
                    */
                    // add new chunks
                    var lowestXZ = lowestBlock();
                    var highestXZ = highestBlock();
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        zoffset = lowestXZ.z + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var z = zoffset; z < zoffset + CHUNK_SIZE * BLOCK_SIZE; z+=BLOCK_SIZE) {
                            xoffset = highestXZ.x + BLOCK_SIZE;
                            for (var x = xoffset; x < xoffset + CHUNK_SIZE * BLOCK_SIZE; x+=BLOCK_SIZE) {
                                xoff = inc * x / BLOCK_SIZE;
                                zoff = inc * z / BLOCK_SIZE;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x, y, z));
                            }
                        }
                        new_chunks.splice(terrain.length - (RENDER_DISTANCE - i), 0, chunk);
                    }
                    terrain = new_chunks;
                    scene.remove(instancedChunk);
                    // reconstruct instanced mesh
                    instancedChunk = new THREE.InstancedMesh(blockBox, materialArray, total_meshes);
                    var count = 0;
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            let matrix = new THREE.Matrix4().makeTranslation(
                                terrain[chunk][block].x,
                                terrain[chunk][block].y,
                                terrain[chunk][block].z
                            );
                            instancedChunk.setMatrixAt(count, matrix);
                            ++count;
                        }
                    }
                    scene.add(instancedChunk);
                }
                var lowestXZ = lowestBlock();
                /*
                       -x     x
                    -z [0][3][6]
                       [1][p][7]
                     z [2][5][8]
                */
                // remove chunks left behind increasing x left West
                if (camera.position.x <= lowestXZ.x + remove_chunk_threshold * BLOCK_SIZE) {
                    /*
                        [0][3]
                        [1][p]
                        [2][5]
                    */
                    // save chunks we dont want to remove
                    var new_chunks = [];
                    for (var chunk = 0; chunk < terrain.length - RENDER_DISTANCE; ++chunk) {
                        new_chunks.push(terrain[chunk]);
                    }
                    /*  
                        [n][3][6]
                        [n][p][7]
                        [n][5][8]
                    */
                    // add new chunks
                    var lowestXZ = lowestBlock();
                    for (var i = 0; i < RENDER_DISTANCE; ++i) {
                        var chunk = [];
                        zoffset = lowestXZ.z + i * CHUNK_SIZE * BLOCK_SIZE;
                        for (var z = zoffset; z < zoffset + CHUNK_SIZE * BLOCK_SIZE; z+=BLOCK_SIZE) {
                            xoffset = lowestXZ.x - CHUNK_SIZE * BLOCK_SIZE;
                            for (var x = xoffset; x < lowestXZ.x; x+=BLOCK_SIZE) {
                                xoff = inc * x / BLOCK_SIZE;
                                zoff = inc * z / BLOCK_SIZE;
                                var y = Math.round(noise.perlin2(xoff, zoff) * amplitude / BLOCK_SIZE) * BLOCK_SIZE;
                                chunk.push(new Block(x, y, z));
                            }
                        }
                        new_chunks.splice(i, 0, chunk);
                    }
                    terrain = new_chunks;
                    scene.remove(instancedChunk);
                    // reconstruct instanced mesh
                    instancedChunk = new THREE.InstancedMesh(blockBox, materialArray, total_meshes);
                    var count = 0;
                    for (var chunk = 0; chunk < terrain.length; ++chunk) {
                        for (var block = 0; block < terrain[chunk].length; ++block) {
                            let matrix = new THREE.Matrix4().makeTranslation(
                                terrain[chunk][block].x,
                                terrain[chunk][block].y,
                                terrain[chunk][block].z
                            );
                            instancedChunk.setMatrixAt(count, matrix);
                            ++count;
                        }
                    }
                    scene.add(instancedChunk);
                }
            }

            const arrayMin = (arr) => arr.reduce(([min], val) => [Math.min(min, val)], [Number.POSITIVE_INFINITY]);
            const arrayMax = (arr) => arr.reduce(([max], val) => [Math.max(max, val)], [Number.NEGATIVE_INFINITY]);

            function lowestBlock() {
                var xPosArray = [];
                var zPosArray = [];
                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        xPosArray.push(terrain[chunk][block].x);
                        zPosArray.push(terrain[chunk][block].z);
                    }
                }
                min_x = arrayMin(xPosArray);
                min_z = arrayMin(zPosArray);

                return {'x': min_x[0], 'z': min_z[0]};
            }

            function highestBlock() {
                var xPosArray = [];
                var zPosArray = [];
                for (var chunk = 0; chunk < terrain.length; ++chunk) {
                    for (var block = 0; block < terrain[chunk].length; ++block) {
                        xPosArray.push(terrain[chunk][block].x);
                        zPosArray.push(terrain[chunk][block].z);
                    }
                }

                max_x = arrayMax(xPosArray);
                max_z = arrayMax(zPosArray);

                return {'x': max_x[0], 'z': max_z[0]};
            }

            function gameloop() {
                requestAnimationFrame(gameloop);
                update();
                render();
            }

            gameloop();
        </script>
    </body>
</html>